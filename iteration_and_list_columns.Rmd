---
title: "iteration and list columns"
output: github_document
    
---


```{r setup, include=FALSE}
library(tidyverse)
library(p8105.datasets)
library(rvest)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

```{r}
set.seed(1)
```

## Vectors

Vector can only hold one type of thing. all numbers, all texts, or true/false values.

```{r}
ver_numeric = 5:8
ver_char = c("My", "name", "is", "eman")
vec_logical = c(TRUE, TRUE, TRUE, FALSE)
```

## Lists
Lists can hold anything.
fixing the above problem.

```{r}
l = list(
  vec_numeric = 5:8,
  mat = matrix (1:8, 2, 4),
  vec_logical = c(TRUE, FALSE),
  summary = summary(rnorm(30))
)
```

You can pull things out of a list using:
access by name, position, or by what's inside, seen below respectovely.

```{r}
l$vec_numeric
l[[1]]
l[[1]][1:3]
```

## for Loops - repeating a task
we now make a list of random numbers (4 sets, called a, b, c, d). each element (a,b,c, d) is a vector of 20 random numbers with different means and sd.

```{r}
list_norms = list(
  a = rnorm(20, 3, 1),
  b = rnorm(20, 0, 5),
  c = rnorm(20, 10, .2),
  d = rnorm(20, -3, 1)
)
```

## Function to summarize one vector

```{r}
mean_and_sd = function(x) {
  
  if (!is.numeric(x)) {
    stop("Argument x should be numeric")
  } else if (length(x) == 1) {
    stop("Cannot be computed for length 1 vectors")
  }
  
  mean_x = mean(x)
  sd_x = sd(x)
  
  tibble(
    mean = mean_x,
    sd = sd_x
  )
}

```


The above does this:
 - checks if input is numeric; if not, it stops and shows an error.
 - checks that the input has more than one number.
 - calculates the mean and sd.
 - returns a small 1-row table (`tibble`) with those values.
 
# Apply the function manually to each element

```{r}
mean_and_sd(list_norms[[1]])
mean_and_sd(list_norms[[2]])
mean_and_sd(list_norms[[3]])
mean_and_sd(list_norms[[4]])
```

## Use a for loop to automate it.
We'll create an empty list first, then fill it up inside a loop.

```{r}
output = vector ("list",length = 4)

for (i in 1:4){
  output[[i]] = mean_and_sd(list_norms[[i]])
}
output
```

the `output` is a list with 4 small tables, one for each example

# The same thing using `map()` (cleaner!)

```{r}
output = map(list_norms, mean_and_sd)
output
```

^ this single line apply the function `mean_and_sd` to each element of the list `list_norms`.

try using median function:
```{r}
output = map(list_norms, median)
output
```

## Use a map variant to get specific output types

```{r}
output = map_dbl(list_norms, median, .id="input")
output

output = map_dfr(list_norms, median, .id="input")
output
```

`map_dbl()` apply the function to each list element and return a numeric vector.
`map_dfr()` combines all results into 1 df (rows).


## List column
# Create a df that contains a list column

```{r}
listcol_df = tibble(
  name = c("a", "b", "c", "d"),
  samp = list_norms
)
```

^ `name` is a text column, and `samp` is a list column.

check:
```{r}
listcol_df |> pull(name)
listcol_df |> pull(samp) 

pull(listcol_df, samp)[[1]]
```

# Apply `mean_and_sd` to the first list manually

```{r}
mean_and_sd(pull(listcol_df, samp)[[1]])
```

# Apply it to ALL list entries using `map()`
```{r}
map(pull(listcol_df, samp), mean_and_sd)
```

```{r}
listcol_df=
  listcol_df |> 
  mutate(summary = map(samp, mean_and_sd))

listcol_df
```

## Nested data - grouping larger datasets

```{r}
library(p8105.datasets)
data("weather_df")
```

nest it:
```{r}
weather_nest = nest(weather_df, data = date:tmin)
weather_nest
```

unnest (return to full form):
```{r}
unnest(weather_nest, cols = data)
```

# fix models (tmax~tmin) for each station

step 1: define a model-fitting function
```{r}
weather_lm = function(df){
  lm(tmax~tmin, data=df)
}
```

step 2: test it on one station's data
```{r}
weather_lm(pull(weather_nest, data)[[1]])
```
this fits a linear regression prediciting max temperature from min temp.

step 3: apply it to all stations using `map()`
```{r}
map(pull(weather_nest, data), weather_lm)
```

step 4: store those models in the df
```{r}
weather_nest=
  weather_nest |> 
  mutate(models=map(data, weather_lm))

weather_nest
```











